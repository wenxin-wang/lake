# vim: filetype=sh

# Error Codes
E_WARGS=1
E_BADDIR=85
E_BADFILE=86
E_BADARCH=87
E_NOTREADY=88

DEFAULT_ARCH=x86_64

lake() {
    pkg=$(basename $pkg)

    if [[ $pkg == *-* ]]
    then
        pkgver=${pkg##*-}
        if [[ $pkgver == [0-9]* ]]
        then
            pkgname=${pkg%-$pkgver}
        else
            pkgname=$pkg
            pkgver=""
        fi
    else
        pkgname=$pkg
    fi

    pkgdir=$pkgs/$pkgname
    verdir=$pkgdir/$pkgver
    cmdfile=$verdir/${pkg}-${arch}
    listname=${pkg}-${arch}.list
    listfile=$verdir/$listname

    if [ "$cmd" != "prepare" ] && ! is_ready
    then
        echo "$cmdfile not ready. Run \"lake prepare $pkg\" first"
        exit $E_NOTREADY
    fi

    case "_$cmd" in
        _print)
            echo $pkgname $pkgver $arch
            ;;
        _prepare)
            prepare_dir
            ;;
        _createlist)
            create_list
            ;;
        _create)
            create_list
            cd $fakeroot/$pkg/$arch
            tar cjf $verdir/${pkg}-${arch}.tar.bz2 *
            ;;
        _backup)
            ;;
        _install)
            create_list
            install_list $fakeroot/$pkg/$arch $listfile
            ln -sv $listfile $currents ;;
        _remove)
            if [[ z"$pkgver" == z ]]
            then
                echo "remove: must specify version"
                exit $E_WARGS
            elif [ ! -d $pkgdir ]
            then
                echo "$pkgname doesn't exist"
                exit $E_WARGS
            fi

            if [ ! -e $currents/$listname ]
            then
                echo "$pkgname $pkgver $arch not installed"
            else
                remove_list $currents/$listname
                rm $currents/$listname
            fi
            ;;
        *)
            echo "$cmd not recognized" ;;
    esac
}


mk_dir() {
    if [ $# -ne 1 ]
    then
        return $E_WARGS
    fi

    local dir=$1
    if [ ! -e $dir ]
    then
        mkdir $dir
        echo "create $dir"
    elif [ ! -d $dir ]
    then
        echo "$dir not a directory"
        exit $E_BADDIR
    else
        echo "directory $dir exists"
    fi
}

mkpkgdir() {
    # create pkgdir, add ver/deps

    echo $pkgdir
    mk_dir $pkgdir
    mk_dir $pkgdir/log

    echo $verdir
    mk_dir $verdir
    touch $verdir/deps
}

gen_list() {
    if [ $# -ne 2 ]
    then
        echo "usage: $0 dirname filename"
        exit 1
    fi

    local dir=$(realpath $1)
    local file=$2
    if [ ! -d $dir ]
    then
        echo "$dir not a directory"
        exit $E_BADDIR
    fi

    if [ -e $file -a ! -f $file ]
    then
        echo "$file not a regular file"
        exit $E_BADFILE
    fi

    find $dir > $file
    sed -i "s@^$dir@@" $file
    sed -i "/^$/d" $file
}

install_list() {
    if [ $# -ne 2 ]
    then
        echo "usage: $0 filesdir listname"
        exit 1
    fi

    local dir=$1
    local list=$2
    local tmp=${list}.tmp # notice that $list is probably in its absolute path

    if [ ! -s $list ]
    then
        echo "Nothing to install"
        exit 0
    fi

    if [ ! -s $tmp ]
    then
        cp $list $tmp
    fi

    while read -u 4 file
    do
        if [ ! -e $dir/$file ]
        then
            echo $dir/$file not found
            exit $E_BADFILE
        elif [ -d $dir/$file -a ! -L $dir/$file ]
        then
            mk_dir $file
        else
            echo install $file
            if [ -e $file ]
            then
                echo $file exists
                handle_collision $file && cp --preserve=mode --no-dereference $dir/$file $file || echo $file >> $list.failed
            else
                cp --preserve=mode --no-dereference $dir/$file $file
            fi
        fi
        sed -i "1d" $tmp
    done 4<$tmp

    if [ -s $list.failed ]
    then
        echo "-----------failed--------------------"
        cat $list.failed
    fi

    rm $tmp
}

remove_list() {
    if [ $# -ne 1 ]
    then
        echo "usage: $0 listname"
        exit 1
    fi

    local list=$1
    local tmp=${list}.tmp # notice that $list is probably in its absolute path

    local file

    if [ ! -s $list ]
    then
        echo "Nothing to remove"
        exit 0
    fi

    if [ ! -s $tmp ]
    then
        cp $list $tmp
    fi

    tac $tmp | while read file
    do
        if [ ! -e $file ]
        then
            echo $file not found
        elif [ -d $file ]
        then
            if [ ! "$(ls -A $file)" ]
            then
                echo remove $file
                rm -r $file
            else
                echo directory $file not empty, leave it alone
            fi
        else
            echo remove $file
            rm $file
        fi
        sed -i "$ d" $tmp
    done

    if [ -e ${list}.failed ]
    then
        mv ${list}.failed{,.old}
    fi

    rm $tmp # remove tmp last, so $dirs will not be overwited when interrupted during dir cleaning
}

prepare_dir() {
    if ! is_ready
    then
        echo "not ready"
        mkpkgdir
        mkcmd
    fi
}

is_ready() {
    if [ -f $cmdfile ]
    then
        return 0
    else
        return 1
    fi
}

create_list() {
    gen_list $fakeroot/$pkg/$arch $listfile
}

mkcmd() {
    if [ ! -e $cmdfile ]
    then
        . /usr/local/lib/mkcmd-${arch}.sh
    fi
}

find_collision() {
    if [ $# -ne 1 ]
    then
        return $E_WARGS
    fi

    local line=$(head -n1 <<< $(grep "^$1$" $currents/*))
    local list=$(cut -d":" -f1 <<< "$line")

    if [[ "z$list" == "z" ]]
    then
        return 0
    fi

    list=$(basename ${list%.*})

    echo $list
}

handle_collision() {  # this is not good enough
    if [ $# -ne 1 ]
    then
        return $E_WARGS
    fi

    local conflict=$(find_collision $1)

    if [ z"$conflict" == z"${pkg}-${arch}" ]
    then
        return 0
    fi

    if [ "$conflict" ]
    then
        echo -n "$1 is in $conflict. Replace it? [y/n] "
        while read command
        do
            case "$command" in
                y|Y)
                    sed -i "\%^$1$%d" $currents/${conflict}.list
                    rm $1
                    echo $1 removed from $conflict
                    return 0 ;;
                n|N)
                    echo $1 kept in $conflict
                    return 1 ;;
                *)
                    echo "Do as I say!"
                    continue ;;
            esac
        done
    else
        echo -n "$1 is not found in any packages. Replace it? [y/n] "

        while read command
        do
            case "$command" in
                y|Y)
                    rm $1
                    echo $1 removed
                    return 0 ;;
                n|N)
                    echo $1 kept
                    return 1 ;;
                *)
                    echo "Do as I say!"
                    continue ;;
            esac
        done
    fi
}
